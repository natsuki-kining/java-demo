# Java并发编程之美 （翟陆续/薛宾田 著）

# 目录
## [前言](#)

## [第一部分 Java并发编程基础篇](#)

* [第1章 并发编程线程基础](#)
    * [1.1 什么是线程](#)
    * [1.2 线程的创建与运行](#)
    * [1.3 线程通知与等待](#)
    * [1.4 等待线程执行终止的join方法](#)
    * [1.5 让线程睡眠的sleep方法](#)
    * [1.6 让出CPU执行权的yield方法](#)
    * [1.7 线程中断](#)
    * [1.8 理解线程上下文切换](#)
    * [1.9 线程死锁](#)
    * [1.10 守护线程与用户线程](#)
    * [1.11 ThreadLocal](#)


* [第2章 并发编程的其他基础知识](#)
    * [2.1 睡眠是多线程并发编程](#)
    * [2.2 为什么要进行多线程并发编程](#)
    * [2.3 Java中的线程安全问题](#)
    * [2.4 Java中共享变量的内存可见性问题](#)
    * [2.5 Java中的synchronized关键字](#)
    * [2.6 Java中的volatile关键字](#)
    * [2.7 Java中的原子性操作](#)
    * [2.8 Java中的CAS操作](#)
    * [2.9 Unsafe类](#)
    * [2.10 Java指令重排序](#)
    * [2.11 伪共享](#)
    * [2.12 锁的概述](#)
    * [2.13 总结](#)

# [第二部分 Java并发编程高级篇](#)
* [第3章 Java并发包中的](#)
    * [3.1 Random类及其局限性](#)
    * [3.2 ThreadLocalRandom](#)
    * [3.3 源码分析](#)
    * [3.4 总结](#)

* [第4章 Java并发包中原子操作类原理剖析](#)
    * [4.1 原子变量操作类](#)
    * [4.2 JDK8新增的原理操作类LongAdder](#)
    * [4.3 LongAccumulator类原理探究](#)
    * [4.4 总结](#)


* [第5章 Java并发包中并发List源码剖析](#)
    * [5.1 介绍](#)
    * [5.2 主要方法和源码解析](#)
    * [5.3 总结](#)

* [第6章 Java并发包中锁原理剖析](#)
    * [6.1 LockSupport工具类](#)
    * [6.2 抽象同步队列AQS概述](#)
    * [6.3 独占锁ReentrantLock的原理](#)
    * [6.4 读写锁ReentrantReadWriteLock的原理](#)
    * [6.5 JDK8中新增的StampedLock锁探究](#)


* [第7章 Java并发包中并发队列原理剖析](#)
    * [7.1 ConcurrentLinkedQueue原理探究](#)
    * [7.2 LinkedBlockQueue原理探究](#)
    * [7.3 ArrayBlockingQueue原理探究](#)
    * [7.4 PriorityBlockingQueue原理探究](#)
    * [7.5 DelayQueue原理探究](#)


* [第8章 Java并发包中线程池ThreadPoolExecutor原理探究](#)
    * [8.1 介绍](#)
    * [8.2 类图介绍](#)
    * [8.3 源码分析](#)
    * [8.4 总结](#)

* [第9章 Java并发包中ScheduledThreadPoolExecutor原理探究](#)
    * [9.1 介绍](#)
    * [9.2 类图介绍](#)
    * [9.3 原理剖析](#)
    * [9.4 总结](#)

* [第10章 Java并发包中线程池同步器原理剖析](#)
    * [10.1 CountDownLatch原理剖析](#)
    * [10.2 回环屏障CyclicBarrier原理探究](#)
    * [10.3 信号量Semaphore原理探究](#)
    * [10.4 总结](#)


# [第三部分 Java并发编程实践篇](#)

* [第11章 并发编程实践](#)

    * [11.1 ArrayBlockingQueue的使用](#)
    * [11.2 Tomcat的NioEndPoint中ConcurrentLinkedQueue的使用](#)
    * [11.3 并发组件ConcurrentHashMap使用注意事项](#)
    * [11.4 SimpleDateFormat是线程不安全的](#)
    * [11.5 使用Timer时需要注意的事情](#)
    * [11.6 对需要复用但是会被下游修改的参数要进行深复制](#)
    * [11.7 创建线程和线程池时需要制定与业务相关的名称](#)
    * [11.8 使用线程池的情况下当线程结束时记得调用shutdown关闭线程池](#)
    * [11.9 线程池使用futureTask时需要注意的事情](#)
    * [11.10 使用ThreadLocal不当可能会导致内存泄露](#)
    * [11.11 总结](#)

# 前言
## 为什么看源码  
&emsp;&emsp;看源码最大的好处是可以开阔思维，提升架构能力。  
有些东西仅靠书本和自己思考很难学到的，必须通过看源码，看别人如何设计，然后思考为什么这样设计才能领悟到。  
能力的提高不在于写了多少代码，做了多少项目，而在于给你一个业务场景时，你是否能拿出集中靠谱的解决方案，并且说出各自的优缺点。  
而如何才能拿出来，一来靠经验，二来靠归纳总结，而看源码可以快速的增加你的经验。

## 如何看源码
* 查找这个开源框架的官方介绍，通过资料了解该框架有几个模块
    * 各个模块是做什么的，之间有什么联系
    * 每个模块都有哪些核心类，阅读源码时可以着重看这些类。
    
* 对感兴趣的模块写个小demo，先了解这个模块的具体作用，然后再debug进入看具体实现。  
* debug
    * 第一遍，走马观花。简略看一下调用逻辑，都用了哪些类
    * 第二遍，重点debug。看看这些类担任了架构图里的哪些功能，使用了哪些设计模式。大致知道整体代码的功能实现。
    * 第三部，画时序图。最好把主要类的调用时序图以及类结构画出来，等画好后，再对着时序图分析调用流程，就可以清楚知道类之间的调用关系，而通过类图可以知道类的功能以及他们相互之间的依赖关系。
    
    
# 第一部分 Java并发编程基础篇

## 第1章 并发编程线程基础
### 1.1 什么是线程
### 1.2 线程的创建与运行
### 1.3 线程通知与等待
### 1.4 等待线程执行终止的join方法
### 1.5 让线程睡眠的sleep方法
### 1.6 让出CPU执行权的yield方法
### 1.7 线程中断
### 1.8 理解线程上下文切换
### 1.9 线程死锁
### 1.10 守护线程与用户线程
### 1.11 ThreadLocal


## 第2章 并发编程的其他基础知识
### 2.1 睡眠是多线程并发编程
### 2.2 为什么要进行多线程并发编程
### 2.3 Java中的线程安全问题
### 2.4 Java中共享变量的内存可见性问题
### 2.5 Java中的synchronized关键字
### 2.6 Java中的volatile关键字
### 2.7 Java中的原子性操作
### 2.8 Java中的CAS操作
### 2.9 Unsafe类
### 2.10 Java指令重排序
### 2.11 伪共享
### 2.12 锁的概述
### 2.13 总结

# 第二部分 Java并发编程高级篇

## 第3章 Java并发包中的
### 3.1 Random类及其局限性
### 3.2 ThreadLocalRandom
### 3.3 源码分析
### 3.4 总结

## 第4章 Java并发包中原子操作类原理剖析
### 4.1 原子变量操作类
### 4.2 JDK8新增的原理操作类LongAdder
### 4.3 LongAccumulator类原理探究
### 4.4 总结


## 第5章 Java并发包中并发List源码剖析
### 5.1 介绍
### 5.2 主要方法和源码解析
### 5.3 总结

## 第6章 Java并发包中锁原理剖析
### 6.1 LockSupport工具类
### 6.2 抽象同步队列AQS概述
### 6.3 独占锁ReentrantLock的原理
### 6.4 读写锁ReentrantReadWriteLock的原理
### 6.5 JDK8中新增的StampedLock锁探究


## 第7章 Java并发包中并发队列原理剖析
### 7.1 ConcurrentLinkedQueue原理探究
### 7.2 LinkedBlockQueue原理探究
### 7.3 ArrayBlockingQueue原理探究
### 7.4 PriorityBlockingQueue原理探究
### 7.5 DelayQueue原理探究


## 第8章 Java并发包中线程池ThreadPoolExecutor原理探究
### 8.1 介绍
### 8.2 类图介绍
### 8.3 源码分析
### 8.4 总结

## 第9章 Java并发包中ScheduledThreadPoolExecutor原理探究
### 9.1 介绍
### 9.2 类图介绍
### 9.3 原理剖析
### 9.4 总结


## 第10章 Java并发包中线程池同步器原理剖析
### 10.1 CountDownLatch原理剖析
### 10.2 回环屏障CyclicBarrier原理探究
### 10.3 信号量Semaphore原理探究
### 10.4 总结


# 第三部分 Java并发编程实践篇

## 第11章 并发编程实践
### 11.1 ArrayBlockingQueue的使用
### 11.2 Tomcat的NioEndPoint中ConcurrentLinkedQueue的使用
### 11.3 并发组件ConcurrentHashMap使用注意事项
### 11.4 SimpleDateFormat是线程不安全的
### 11.5 使用Timer时需要注意的事情
### 11.6 对需要复用但是会被下游修改的参数要进行深复制
### 11.7 创建线程和线程池时需要制定与业务相关的名称
### 11.8 使用线程池的情况下当线程结束时记得调用shutdown关闭线程池
### 11.9 线程池使用futureTask时需要注意的事情
### 11.10 使用ThreadLocal不当可能会导致内存泄露
### 11.11 总结